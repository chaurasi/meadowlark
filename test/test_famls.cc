/*
 *  (c) Copyright 2022 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the
 *  GNU Lesser General Public License Version 3, or (at your option)
 *  later with exceptions included below, or under the terms of the
 *  MIT license (Expat) available in COPYING file in the source tree.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <gtest/gtest.h>

#include "radixtree/radix_tree.h"

#include "nvmm/memory_manager.h"
#include "nvmm/heap.h"
#include "nvmm/fam.h"


using namespace radixtree;
using namespace nvmm;

void print_usage_and_exit(char **argv);

void rccpause();

#define MYBUF_SIZE  1024

uint64_t root64r;
int nkeys = 0;

void rccpause(){
    int t;
	printf("WORKER IS WAITING on scanf()!!! -- hit any key\n");
    scanf("%d", &t);
}

// famls
TEST(RadixTree, RCCFAMLS) {
    PoolId const heap_id = 1; // assuming we only use heap id 1
    size_t const heap_size = 1024*1024*1024; // 1024MB

    // init memory manager and heap
    MemoryManager *mm = MemoryManager::GetInstance();
    Heap *heap = nullptr;
	if(root64r == 0){
    	EXPECT_EQ(NO_ERROR, mm->CreateHeap(heap_id, heap_size));
	}
    EXPECT_EQ(NO_ERROR, mm->FindHeap(heap_id, &heap));
    EXPECT_NE(nullptr, heap);

    // open the heap
    EXPECT_EQ(NO_ERROR, heap->Open());

    // init the radix tree
    RadixTree *tree = nullptr;
	uint64_t root64;
	Gptr root(root64r);
    TagGptr result;
    char keyb[RadixTree::MAX_KEY_LEN];
    char key_buf[RadixTree::MAX_KEY_LEN];
    size_t key_size;
    uint64_t value;
    uint64_t *value_ptr;
    GlobalPtr value_gptr;
    int key_id = 0;
    char operation[128];
    bool flag_recursive;


	if(root64r == 0){
        // create a new radix tree
        tree = new RadixTree(mm, heap, NULL);
        root = tree->get_root();
        EXPECT_NE(nullptr, tree);
        //delete tree;

		std::cout << "root => " << root << std::endl;
		root64 = root.ToUINT64();
		printf("==> root64r: 0x%lx\n\n", root64);

            // populate tree
            //memset(key_buf, 0, sizeof(key_buf));

            if(nkeys) std::cout << "ENTER " << nkeys << " NODE KEYS" << std::endl;
            while (nkeys-- > 0){
                scanf("%s", keyb);

                // put 1:1
                key_size = strlen(keyb);
                if (key_size == 0 || key_size >= RadixTree::MAX_KEY_LEN){
                    std::cout << "Invalid key entered |" << keyb;
                    std::cout << "| size (" << key_size << ") " << std::endl;
                    nkeys++;
                    continue;
                }
                memcpy(key_buf, (char*)keyb, key_size);
                key_buf[key_size] = 0;

                value = key_id++;
                value_gptr = heap->Alloc(sizeof(value));
                value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
                *value_ptr = value;
                fam_persist(value_ptr, sizeof(value));

                result = tree->put(key_buf, key_size, value_gptr, UPDATE);
            }

            while(1){
                std::cout << "Enter operation:" << std::endl;
                std::cout << "\t \"q\" - QUIT" << std::endl;
                std::cout << "\t \"g\" - GET" << std::endl;
                std::cout << "\t \"p\" - PUT" << std::endl;
                std::cout << "\t \"r|s\" - recursive|single SEARCH -- ";

                scanf("%s", operation);

                if(!strcmp(operation, "q")){
                    break;
                }

                std::cout << "Enter key -- ";
                scanf("%s", keyb);
                std::cout << std::endl;

                if(!strcmp(operation, "r")){
                    flag_recursive = 1;
                }else{
                    flag_recursive = 0;
                }

                if(!strcmp(operation, "g")){
    	        	std::cout <<" DOING get(key_buf==" << keyb <<", key_size==";
                    std::cout << strlen(keyb) <<")" << std::endl;
	            	result = tree->get(keyb, strlen(keyb));
        	        Gptr rr(result.gptr_);
        	    	std::cout << "result (rr) => " << rr << std::endl;
                    if(result.gptr_){
        	        	uint64_t *rcc_value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr_);
        	        	printf("value: %ld\n", fam_atomic_64_read((int64_t *)rcc_value_ptr));
                    }
                }

                else if(!strcmp(operation, "p")){
                    key_size = strlen(keyb);
                    if (key_size ==0 || key_size >= RadixTree::MAX_KEY_LEN){
                        std::cout << "Invalid key entered |" << keyb;
                        std::cout << "| size (" << key_size << ") " << std::endl;
                        continue;
                    }
                    memcpy(key_buf, (char*)keyb, key_size);
                    key_buf[key_size] = 0;

                    value = key_id++;
                    value_gptr = heap->Alloc(sizeof(value));
                    value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
                    *value_ptr = value;
                    fam_persist(value_ptr, sizeof(value));

                    result = tree->put(key_buf, key_size, value_gptr, UPDATE);
                }

                else{
                    char mybuf[MYBUF_SIZE] = {""};
                    std::cout << "\n\nTREE LISTING" << std::endl;
                    std::cout << "============" << std::endl;
                    int ret = tree->traverse(root, keyb, flag_recursive, mybuf, MYBUF_SIZE);
                    if(ret == 2){ 
                        if((!flag_recursive) || (!strlen(mybuf))) printf("insufficient user buffer\n");
                        else printf("PARTIAL LISTING\n");
                    }
                    printf("%s\n", mybuf);
                    std::cout << "------------" << std::endl;
                }
            }

    	    //rccpause();

            delete tree;

            EXPECT_EQ(NO_ERROR, heap->Close());
            //EXPECT_EQ(NO_ERROR, mm->DestroyHeap(heap_id));
    } else {

		std::cout << "root => " << root << std::endl;
		printf("==> root64r: 0x%lx\n\n", root64r);

        // open an existing radix tree
        tree = new RadixTree(mm, heap, NULL, root);
        EXPECT_NE(nullptr, tree);

            // open an existing radix tree
            tree = new RadixTree(mm, heap, NULL, root);
            EXPECT_NE(nullptr, tree);

            while(1){
                std::cout << "Enter operation:" << std::endl;
                std::cout << "\t \"q\" - QUIT" << std::endl;
                std::cout << "\t \"g\" - GET" << std::endl;
                std::cout << "\t \"p\" - PUT" << std::endl;
                std::cout << "\t \"r|s\" - recursive|single SEARCH -- ";

                scanf("%s", operation);

                if(!strcmp(operation, "q")){
                    break;
                }

                std::cout << "Enter key -- ";
                scanf("%s", keyb);
                std::cout << std::endl;

                if(!strcmp(operation, "r")){
                    flag_recursive = 1;
                }else{
                    flag_recursive = 0;
                }

                if(!strcmp(operation, "g")){
    	        	std::cout <<" DOING get(key_buf==" << keyb <<", key_size==";
                    std::cout << strlen(keyb) <<")" << std::endl;
	            	result = tree->get(keyb, strlen(keyb));
        	        Gptr rr(result.gptr_);
        	    	std::cout << "result (rr) => " << rr << std::endl;
                    if(result.gptr_){
        	        	uint64_t *rcc_value_ptr = (uint64_t*)mm->GlobalToLocal(result.gptr_);
        	        	printf("value: %ld\n", fam_atomic_64_read((int64_t *)rcc_value_ptr));
                    }
                }

                else if(!strcmp(operation, "p")){
                    key_size = strlen(keyb);
                    if (key_size ==0 || key_size >= RadixTree::MAX_KEY_LEN){
                        std::cout << "Invalid key entered |" << keyb;
                        std::cout << "| size (" << key_size << ") " << std::endl;
                        continue;
                    }
                    memcpy(key_buf, (char*)keyb, key_size);
                    key_buf[key_size] = 0;

                    value = key_id++;
                    value_gptr = heap->Alloc(sizeof(value));
                    value_ptr = (uint64_t*)mm->GlobalToLocal(value_gptr);
                    *value_ptr = value;
                    fam_persist(value_ptr, sizeof(value));

                    result = tree->put(key_buf, key_size, value_gptr, UPDATE);
                }

                else{
                    char mybuf[MYBUF_SIZE] = {""};
                    std::cout << "\n\nTREE LISTING" << std::endl;
                    std::cout << "============" << std::endl;
                    int ret = tree->traverse(root, keyb, flag_recursive, mybuf, MYBUF_SIZE);
                    if(ret == 2){ 
                        if((!flag_recursive) || (!strlen(mybuf))) printf("insufficient user buffer\n");
                        else printf("PARTIAL LISTING\n");
                    }
                    printf("%s\n", mybuf);
                    std::cout << "------------" << std::endl;
                    std::cout << std::endl;
                }
            }
            
    	    //rccpause();

            delete tree;

            EXPECT_EQ(NO_ERROR, heap->Close());
            //EXPECT_EQ(NO_ERROR, mm->DestroyHeap(heap_id));
    }
}

void Init()
{
    if(!root64r){
        nvmm::ResetNVMM();
        nvmm::StartNVMM();
    }
}

void print_usage_and_exit(char **argv)
{
    std::cout << "Usage: " << argv[0] << " <startworker> (0=>creator, valid Gptr=>others) "; 
    std::cout <<" [<number-of-nodes>] " << std::endl;

    exit(1);
}

int main (int argc, char **argv) {

    if(argc != 2 && argc != 3){
        print_usage_and_exit(argv);
    }

	root64r = strtoul(argv[1], 0, 0);

    if(argc == 3) {
        nkeys = atoi(argv[2]);
    }

    Init();
    ::testing::InitGoogleTest(&argc, argv);

    return RUN_ALL_TESTS();

}
